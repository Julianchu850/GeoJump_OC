/**
 * GeometryGame 
 * GeometryGame.run retorna el puntaje cuando el jugador choca, y 0 cuando el jugador sale (q)
 */
class GeometryGame {
    field int delay;
    field int absoluteDelay;
    
    field Cube player;
    field int playerTlx;
    field int playerTly;
    field int playerBrx;
    field int playerBry;
    
    field Spaceship flying0;
    field Spaceship flying1;
    field Spaceship flying2;

    field SpikeCluster cactus0;
    field SpikeCluster cactus1;
    field SpikeCluster cactus2;
    field SpikeCluster cactus3;
    field SpikeCluster cactus4;
    
    field boolean crashed;
    
    field int achievementTimeoutCycles;
    field int clock;
    field int score;
    field int highScore;
    field int lastCycleKey;
    
    constructor GeometryGame new(int highestScore) {
        let player = Cube.new(7300);
        let playerTlx = 4;
        let playerBrx = 5;
        let playerTly = player.collisionBoxTly();
        let playerBry = playerTly + 32;
        
        let flying0 = Spaceship.new();
        let flying1 = Spaceship.new();
        let flying2 = Spaceship.new();
        
        let cactus0 = SpikeCluster.new();
        let cactus1 = SpikeCluster.new();
        let cactus2 = SpikeCluster.new();
        let cactus3 = SpikeCluster.new();
        let cactus4 = SpikeCluster.new();
        
        let absoluteDelay = 25;
        let delay = absoluteDelay - 4;
        let crashed = false;
        
        let achievementTimeoutCycles = -1;
        let clock = 0;
        let score = 0;
        let highScore = highestScore;
        let lastCycleKey = 0;
        
        // configurar pantalla
        do Screen.clearScreen();
        do Output.moveCursor(0, 0);
        do Output.printString("High Score: ");
        do Output.moveCursor(0, 12);
        do Output.printInt(highScore);
        
        // do Achievements.writeAchievementsLeft();
        
        do Output.moveCursor(1, 0);
        do Output.printString("Score: ");
        do Output.moveCursor(1, 7);
        do Output.printInt(score);
        
        return this;
    }

    method void dispose() {
        do player.dispose();
        
        do flying0.dispose();
        do flying1.dispose();
        do flying2.dispose();
        
        do cactus0.dispose();
        do cactus1.dispose();
        do cactus2.dispose();
        do cactus3.dispose();
        do cactus4.dispose();
        
        do Memory.deAlloc(this);
        return;
    }

    method void setAchievementTimeout(int durationCycles) {
        // si durationCycles == 0, usar duración por defecto
        if (durationCycles) {
            let achievementTimeoutCycles = durationCycles;
        }
        else {
            let achievementTimeoutCycles = 150;
        }
        let delay = absoluteDelay - 4; // resetear delay si es necesario
        return;
    }

    method boolean checkInput() {
        var int key;
        var boolean salto;
        let key = Keyboard.keyPressed();
        let salto = false;

        if ((key = 32) | (key = 131)) { // barra espaciadora o flecha arriba para saltar
            let salto = player.jump();
            
            // solo cuenta para el logro de salto si el usuario no está manteniendo la tecla
            // y si player.jump() reporta un salto desde el suelo o techo
            if (~(key = lastCycleKey) & (salto)) {
                if (Achievements.complete(5)) { do setAchievementTimeout(0); }
            }
        }
        else {
            if (key = 133) { // flecha abajo → inversión de gravedad
                do player.crouch(); // en Cube, esto llama a flipGravity()
                if (Achievements.complete(7)) { do setAchievementTimeout(0); }
            }
            else {
                if (key = 81) {  // Q para salir
                    return false;
                }
                else {
                    if ((key = 130) & ~(lastCycleKey = 130)) { // izquierda: ajustar velocidad de salto
                        do Cube.updateJump(-1);
                        if (Achievements.complete(1)) { do setAchievementTimeout(0); }
                    }
                    else {
                        if ((key = 132) & ~(lastCycleKey = 132)) { // derecha: ajustar velocidad de salto
                            do Cube.updateJump(1);
                            if (Achievements.complete(1)) { do setAchievementTimeout(0); }
                        }
                        else {
                            if ((key > 47) & (key < 58)) { // tecla dígito: cambiar velocidad del juego
                                let delay = absoluteDelay - (key - 48); 
                                if (delay < 1) {
                                    let delay = absoluteDelay - 4;
                                }
                                if (Achievements.complete(6)) { do setAchievementTimeout(250); }
                            }
                        }
                    }
                }
            }
        }

        let lastCycleKey = key;
        return true;
    }



    method int run() {
        var int temp;

        while (~crashed) {
            if (checkInput()) {
                // actualizar el estado de cada objeto
                if (player.update() = 0) { // evento especial de player.update()
                    if (Achievements.complete(0)) { do setAchievementTimeout(0); }
                }
                
                do flying0.update();
                do flying1.update();
                do flying2.update();
                do Spaceship.decrementRightmost();
                
                do cactus0.update();
                do cactus1.update();
                do cactus2.update();
                do cactus3.update();
                do cactus4.update();
                do SpikeCluster.decrementRightmost();
                            
                // verificar colisiones
                let playerTly = player.collisionBoxTly();
                let playerBry = playerTly + 32;
                
                // verificar colisiones con naves y trampolines
                // Solo una puede colisionar a la vez, así que sumamos los retornos de colisión:
                // -1 = trampolín, 1 = choque, 0 = sin colisión
                let temp =
                    flying0.collision(playerTlx, playerTly, playerBrx, playerBry) +
                    flying1.collision(playerTlx, playerTly, playerBrx, playerBry) +
                    flying2.collision(playerTlx, playerTly, playerBrx, playerBry);
                
                if (temp < 0) { // rebotando en trampolín
                    if (Achievements.complete(8)) { do setAchievementTimeout(0); }
                    
                    // rebotar el cubo hacia arriba
                    do player.setVelocity(-20);
                    
                    // resetear la nave que fue golpeada
                    if (flying0.collision(playerTlx, playerTly, playerBrx, playerBry)) { do flying0.reset(true); }
                    if (flying1.collision(playerTlx, playerTly, playerBrx, playerBry)) { do flying1.reset(true); }
                    if (flying2.collision(playerTlx, playerTly, playerBrx, playerBry)) { do flying2.reset(true); }
                }
                else {
                    if (temp > 0) { // chocó con nave
                        let crashed = true;
                    }
                }
                
                // colisiones con pinchos
                if (cactus0.collision(playerTlx, playerTly, playerBrx, playerBry) | 
                    cactus1.collision(playerTlx, playerTly, playerBrx, playerBry) |
                    cactus2.collision(playerTlx, playerTly, playerBrx, playerBry) |
                    cactus3.collision(playerTlx, playerTly, playerBrx, playerBry) |
                    cactus4.collision(playerTlx, playerTly, playerBrx, playerBry)) {

                     // Intenta completar el achievement 2
                // Si retorna TRUE = primera colisión (perdona)
                // Si retorna FALSE = ya estaba completo (crashea)
                if (Achievements.complete(2)) {
                    // Primera vez: solo muestra mensaje
                    do setAchievementTimeout(150);
                }
                else {
                    // Segunda+ vez: game over
                    let crashed = true;
                }
                
                // ✅ NO SE RESETEA NADA - Flujo continuo
            }

            // retardo de velocidad del juego
            do Sys.wait(delay);
            
        }
        else {
            return 0; // salir
        }

            // actualizar y mostrar puntaje cada 4 ciclos
            if (clock = 3) {
                let clock = 0; 
                let score = score + 1;
                do Output.moveCursor(1, 7);
                do Output.printInt(score);
                
                // actualizar delay en ciertos puntajes
                if ((score = 150) | (score = 250) | (score = 500) | (score = 1000)) {
                    let absoluteDelay = absoluteDelay - 1;
                    let delay = absoluteDelay - 4;
                    
                    // verificar logro de 1000 puntos
                    if (score = 1000) {
                        do Achievements.complete(4);
                        do setAchievementTimeout(0);
                    }
                }
                
                // si puntaje > 1500, ver si el juego terminó
                if (score > 1499) {
                    do Achievements.complete(-1);
                }
            }
            else {
                let clock = clock + 1;
            }
            
            if (achievementTimeoutCycles = 0) {
                do Achievements.clearMessage();
            }
            let achievementTimeoutCycles = achievementTimeoutCycles - 1;
        }

        // fin del juego: retornar mejor puntaje
        if (score > highScore) {
            return score;
        }
        return highScore;
    }
}