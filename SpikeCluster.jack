class SpikeCluster {
    // Tracks how far to the right the last spike cluster was placed (in word units)
    static int rightmost;
    static int moveCounter;  // ← AGREGAR: Contador para movimiento lento

    // Basic geometry
    field int height;          // in pixels
    field int width;           // in words (1 or 2)
    field int location;        // top-left screen word index for sprite (for Graphics)
    field int sprite;          // 1 = small spike, 2 = big spike

    // Collision box (word-based x, pixel-based y)
    field int tlx;             // top-left x (in words)
    field int tly;             // top-left y (in pixels)
    field int brx;             // bottom-right x (in words)
    field int bry;             // bottom-right y (in pixels)

    /** constructor */
    constructor SpikeCluster new() {
        do reset();
        // If rightmost is still uninitialized (0), put it just off the right edge
        if (~rightmost) {
            let rightmost = 30;
        }
        // ← AGREGAR: Inicializar contador
        let moveCounter = 0;
        return this;
    }

    /** decrementRightmost */
    function void decrementRightmost() {
        // ← AGREGAR: Solo decrementa cada 2 frames (más lento)
        let moveCounter = moveCounter + 1;
        if (moveCounter > 3) {  // Cambiar a 2, 3, 4... para más lento
            let moveCounter = 0;
            let rightmost = rightmost - 1;
            if (rightmost < 30) {
                let rightmost = 29;
            }
        }
        return;
    }

    /** dispose */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    /** x */
    method int x() {
        return brx;
    }

    /** update - MODIFICADO para movimiento más lento */
    method void update() {
        var int oldLocation;

        // If spike has not entered the visible part of the screen yet
        if (tlx > 30) {
            // ✅ CAMBIO: Solo mueve cada 2 frames
            if ((moveCounter / 2) * 2 = moveCounter) {  // Si moveCounter es par
                let location = location - 1;
                let tlx = tlx - 1;
                let brx = brx - 1;
            }
            return;
        }

        // Erase the sprite at the previous location (if any)
        let oldLocation = location;
        if (sprite = 1) {
            do Graphics.eraseSpike1(oldLocation);
        }
        else {
            if (sprite = 2) {
                do Graphics.eraseSpike2(oldLocation);
            }
        }

        // ✅ CAMBIO: Move one word to the left SOLO cada 2 frames
        if ((moveCounter / 2) * 2 = moveCounter) {  // Si moveCounter es par
            let location = location - 1;
            let tlx = tlx - 1;
            let brx = brx - 1;
        }

        // If the spike is completely past the left side, spawn a new one
        if (brx < 0) {
            do reset();
            return;
        }

        // Draw the sprite at the new location
        if (sprite = 1) {
            do Graphics.drawSpike1(location);
        }
        else {
            if (sprite = 2) {
                do Graphics.drawSpike2(location);
            }
        }

        return;
    }

    /** reset */
    method void reset() {
        // Choose which spike sprite we will use
        let sprite = LCGRandom.randRange(1, 2);

        if (sprite = 1) {
            let height = 21;
            let width  = 1;
        }
        else {
            if (sprite = 2) {
                let height = 16;
                let width  = 2;
            }
        }

        let tly = 244 - height;
        let tlx = rightmost + LCGRandom.randRange(20, 150);
        let rightmost = tlx;
        let bry = 244;
        let brx = tlx + width;
        let location = (7808 - (height * 32)) + tlx;

        return;
    }

    /** collision */
    method boolean collision(int tl1x, int tl1y, int br1x, int br1y) {
        if ((tlx > br1x) | (tl1x > brx)) {
            return false;
        }
        if ((tly > br1y) | (tl1y > bry)) {
            return false;
        }
        return true;
    }
}