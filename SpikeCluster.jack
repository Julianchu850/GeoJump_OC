class SpikeCluster {
    // Tracks how far to the right the last spike cluster was placed (in word units)
    static int rightmost;
    static int minGap;  // AGREGAR: Contador para movimiento lento
    field boolean hasCollided;  // Nuevo campo


    // Basic geometry
    field int height;          // in pixels
    field int width;           // in words (1 or 2)
    field int location;        // top-left screen word index for sprite (for Graphics)
    field int sprite;          // 1 = small spike, 2 = big spike

    // Collision box (word-based x, pixel-based y)
    field int tlx;             // top-left x (in words)
    field int tly;             // top-left y (in pixels)
    field int brx;             // bottom-right x (in words)
    field int bry;             // bottom-right y (in pixels)

    /** constructor */
    constructor SpikeCluster new() {
        do reset();
        // If rightmost is still uninitialized (0), put it just off the right edge
        if (~rightmost) {
            let rightmost = 25;
        }
        if (~minGap) {
            let minGap = 20;  // Minimo 12 palabras entre spikes
        }
            let hasCollided = false;  // Inicializar

        return this;
    }

   function void decrementRightmost() {
    // Eliminar el contador, mover siempre
    let rightmost = rightmost - 1;
    if (rightmost < 25) {
        let rightmost = 24;
    }
    return;
}

method void update() {
    var int oldLocation;

    if (tlx > 30) {
        let location = location - 1;
        let tlx = tlx - 1;
        let brx = brx - 1;
        return;
    }

    let oldLocation = location;
    if (sprite = 1) {
        do Graphics.eraseSpike1(oldLocation);
    }
    else {
        if (sprite = 2) {
            do Graphics.eraseSpike2(oldLocation);
        }
    }

    // Mover siempre, sin contador
    let location = location - 1;
    let tlx = tlx - 1;
    let brx = brx - 1;

    if (brx < 0) {
        do reset();
        return;
    }

    if (sprite = 1) {
        do Graphics.drawSpike1(location);
    }
    else {
        if (sprite = 2) {
            do Graphics.drawSpike2(location);
        }
    }

    return;
}

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    /** reset */
    method void reset() {
        // Choose which spike sprite we will use
        let sprite = LCGRandom.randRange(1, 2);

        if (sprite = 1) {
            let height = 21;
            let width  = 1;
        }
        else {
            if (sprite = 2) {
                let height = 16;
                let width  = 2;
            }
        }

        let tly = 244 - height;
        let tlx = rightmost + LCGRandom.randRange(20, 150) + minGap;
        let rightmost = tlx;
        let bry = 244;
        let brx = tlx + width;
        let location = (7808 - (height * 32)) + tlx;
        let hasCollided = false;  // Reset cuando reaparece

        return;
    }

    /** collision */
    method boolean collision(int tl1x, int tl1y, int br1x, int br1y) {
        if (hasCollided) {  // ignorar si ya colisiono
        return false;
        }

        if ((tlx > br1x) | (tl1x > brx)) {
            return false;
        }
        if ((tly > br1y) | (tl1y > bry)) {
            return false;
        }
        let hasCollided = true;  // Marcar como colisionado
        return true;
    }
}