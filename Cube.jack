/**
 * Cube.jack
 * Geometry Dash Edition - Player Character
 */
class Cube {
    // -------- static physics constants --------
    static int gravityConst;    // gravity strength
    static int jumpVelocity;    // initial jump speed (negative = up)
    
    // -------- instance fields --------
    
    // position and movement
    field int location;         // current screen memory location
    field int initialLocation;  // ground level position (reset point)
    field int velocity;         // current vertical velocity
    field int height;           // current Y position (in word rows)
    field int initialHeight;    // ground level height
    
    // visual state
    field int cubeType;         // which cube variant (1-4)
    field int clock;            // animation timer
    
    // gravity flip system
    field boolean gravityFlipped; // true = upside down on ceiling
    field int flipCooldown;       // prevents rapid flip spamming
    
    // legacy fields
    field boolean feetPos;
    field int crouchState;
    
    /**
     * Constructor
     */
    constructor Cube new(int pos) {
        // initialize physics constants
        let gravityConst = 2; 
        let jumpVelocity = -24; 
        
        // set initial position
        let location = pos;
        if (location = 0) {
            let location = 7300; 
        }
        
        // calculate heights
        let initialHeight = ((location / 32) - 16);
        let height = initialHeight;
        let initialLocation = location;
        
        // initialize movement
        let velocity = 0;
        let clock = 0;
        
        // gravity system
        let gravityFlipped = false;
        let flipCooldown = 0;
        
        // legacy fields
        let feetPos = true;
        let crouchState = 0;
        
        // randomly select cube variant
        let cubeType = LCGRandom.randRange(1, 4);
        do drawCube();
        
        return this;
    }
    
    /** dispose this object */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    
    // -------- drawing methods --------
    
    /** draw cube based on selected variant */
    method void drawCube() {
        if (cubeType = 1) { do Graphics.drawCube1(location); }
        else {
            if (cubeType = 2) { do Graphics.drawCube2(location); }
            else {
                if (cubeType = 3) { do Graphics.drawCube3(location); }
                else { do Graphics.drawCube4(location); }
            }
        }
        return;
    }
    
    /** erase cube from current position */
    method void eraseCube(int loc) {
        do Graphics.eraseCube(loc);
        return;
    }
    
    // -------- physics and movement --------
    
    /**
     * update:
     * called every frame from the game loop
     */
    method int update() {
        var int oldLocation;
        var int movementDelta;

        // decrement flip cooldown
        if (flipCooldown > 0) {
            let flipCooldown = flipCooldown - 1;
        }
        
        // store old position for erasing
        let oldLocation = location;

        // apply gravity to velocity
        if (gravityFlipped) {
            let velocity = velocity - gravityConst; // inverted: gravity pulls up
        }
        else {
            let velocity = velocity + gravityConst; // normal: gravity pulls down
        }
        
        // apply velocity to position
        let location = location + (32 * velocity);
        let height = height + velocity;

        // --- SAFETY LIMITS (FIXED) ---
        
        // 1. TOP LIMIT (Absolute Ceiling)
        // Prevents memory corruption (Out of segment space error)
        if (location < 0) {
            let location = 0;
            let height = 0; 
            if (velocity < 0) { let velocity = 0; } // Stop upward momentum
        }
        else {
            // Inverted Mode: Ceiling collision
            if (gravityFlipped) {
                 if (height < 32) {
                    let height = 32;
                    let location = (32 * 32); // Fixed ceiling position
                    let velocity = 0;
                }
            }
        }

        // 2. BOTTOM LIMIT (Absolute Floor)
        // Prevents falling out of memory bounds
        if (location > initialLocation) {
            let location = initialLocation;
            let height = initialHeight;
            let velocity = 0;
        }
        // -----------------------------
        
        // calculate how far we moved
        let movementDelta = (location - oldLocation) / 32;

        // only redraw if position changed
        if (~(movementDelta = 0)) {
            do eraseCube(oldLocation);
            do drawCube();
        }
        
        return -1;
    }
    
    /**
     * jump:
     * makes cube jump (or fall if gravity is flipped)
     */
    method int jump() {
        // normal gravity: jump if on ground
        if (~gravityFlipped) {
            if (location = initialLocation) {
                let velocity = jumpVelocity; 
                return true;
            }
        }
        // inverted gravity: jump (fall down) if on ceiling
        else {
            if (height = 32) {
                let velocity = -jumpVelocity; 
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * flipGravity:
     * toggles gravity direction
     */
    method void flipGravity() {
        // can only flip in mid-air and if cooldown allows
        if ((flipCooldown = 0) & (~(velocity = 0))) {
            // toggle gravity
            let gravityFlipped = ~gravityFlipped;
            
            // Note: Velocity is NOT inverted here to allow smooth arc
            
            // set cooldown to prevent spam
            let flipCooldown = 10;
        }
        return;
    }
    
    // -------- input helpers --------
    
    /** crouch repurposed as gravity flip trigger */
    method void crouch() {
        do flipGravity();
        return;
    }
    
    /** setVelocity directly */
    method void setVelocity(int vel) {
        let velocity = vel;
        return;
    }
    
    // -------- collision helpers --------
    
    method int collisionBoxTly() {
        return height;
    }
    
    method boolean isGrounded() {
        if (gravityFlipped) {
            return (height = 32);
        }
        return (location = initialLocation);
    }
    
    method boolean isGravityFlipped() {
        return gravityFlipped;
    }
    
    // -------- static physics tuning --------
    
    function void setPhysics(int gravity, int jumpPower) {
        let gravityConst = gravity;
        let jumpVelocity = jumpPower;
        return;
    }
    
    function void updateJump(int change) {
        let jumpVelocity = jumpVelocity - (change * 5);
        if ((jumpVelocity < (-45)) | (jumpVelocity > (-15))) {
            let jumpVelocity = -24;
        }
        return;
    }
    
    method void swapFeet() {
        let feetPos = ~feetPos;
        return;
    }
}