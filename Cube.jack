
/**
 * Cube.jack
 * Geometry Dash Edition - Personaje del jugador
 * 
 * Transformado desde Trex.jack (Juego del Dino)
 * 
 * Cambios respecto al original:
 * 1. Dinosaurio → cubo geométrico (4 variantes aleatorias)
 * 2. Movimiento orgánico → física rápida y precisa
 * 3. Mecánica de agacharse → mecánica de invertir la gravedad
 * 4. Animaciones complejas → renderizado geométrico simple
 * 5. Saltos flotantes → saltos precisos estilo arcade
 * 
 * Mecánicas:
 * - Salto: espacio o flecha arriba (cambio instantáneo de velocidad)
 * - Invertir gravedad: flecha abajo mientras está en el aire (invierte la dirección de la gravedad)
 * - Gravedad normal: cubo en el suelo, salta hacia arriba
 * - Gravedad invertida: cubo en el techo, salta hacia abajo
 */


class Cube {
    // -------- constantes estáticas de física --------
    static int gravityConst;      // fuerza de gravedad (positivo = abajo)
    static int jumpVelocity;      // velocidad inicial de salto (negativo = arriba)
    
    // -------- campos de instancia --------
    
    // posición y movimiento
    field int location;           // ubicación actual en memoria de pantalla
    field int initialLocation;    // posición del nivel del suelo (punto de reinicio)
    field int velocity;           // velocidad vertical actual
    field int height;             // posición Y actual (en filas de palabras)
    field int initialHeight;      // altura del nivel del suelo
    
    // estado visual
    field int cubeType;           // qué variante de cubo (1-4)
    field int clock;              // temporizador de animación (poco usado)
    
    // sistema de inversión de gravedad
    field boolean gravityFlipped; // true = boca abajo en el techo
    field int flipCooldown;       // previene spam rápido de inversión
    
    // campos legacy (mantenidos para compatibilidad con código viejo)
    field boolean feetPos;        // cuadro de animación alternante (no usado)
    field int crouchState;        // legacy, mantenido para compatibilidad
    
    /**
     * Constructor
     * pos: ubicación en memoria de pantalla (usar 7300 para posición por defecto en el suelo)
     */
    constructor Cube new(int pos) {
        var String line;
        // inicializar constantes de física
        let gravityConst = 2;       // reducido de 3 para sensación más precisa
        let jumpVelocity = -24;     // reducido de -30 para más control
        
        // establecer posición inicial
        let location = pos;
        if (location = 0) {
            let location = 7300;    // por defecto: cerca del lado izquierdo, nivel del suelo
        }
        
        // calcular alturas (altura en filas de palabras, no píxeles)
        let initialHeight = ((location / 32) - 16);  // 16 palabras de alto - FIXED: agregados paréntesis extra
        let height = initialHeight;
        let initialLocation = location;
        
        // inicializar movimiento
        let velocity = 0;
        let clock = 0;
        
        // sistema de gravedad
        let gravityFlipped = false;
        let flipCooldown = 0;
        
        // campos legacy
        let feetPos = true;
        let crouchState = 0;
        
        // establecer el cubo elegido por jugador
        let cubeType = Startscreen.getCubeNum();
    
        // dibujar cubo inicial
        do drawCube(cubeType);
        
        return this;
    }
    
    /** liberar este objeto */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    
    // -------- métodos de dibujo --------
    
    /** dibujar cubo basado en la variante seleccionada */
    method void drawCube(int cubeNum) {
        if (cubeNum = 1) { 
            do Graphics.drawCube1(location);
        }
        else {
            if (cubeNum = 2) {
                do Graphics.drawCube2(location);
            }
            else {
                if (cubeNum = 3) { 
                    do Graphics.drawCube3(location);
                }
                else {
                    do Graphics.drawCube4(location);
                }
            }
        }
        return;
    }
    
    /** borrar cubo de la posición actual */
    method void eraseCube(int loc) {
        do Graphics.eraseCube(loc);
        return;
    }
    
    // -------- física y movimiento --------
    
    /**
     * update:
     * llamado cada frame desde el bucle del juego
     * maneja gravedad, movimiento, colisiones con suelo/techo, y dibujo
     * retorna:
     *   -1 = actualización normal
     *    0 = reservado para eventos especiales (no usado ahora)
     */
    method int update() {
        var int oldLocation;
        var int movementDelta;
        
        // decrementar cooldown de inversión
        if (flipCooldown > 0) {
            let flipCooldown = flipCooldown - 1;
        }
        
        // guardar posición antigua para borrar
        let oldLocation = location;
        
        // aplicar gravedad a velocidad
        if (gravityFlipped) {
            let velocity = velocity - gravityConst;   // invertido: gravedad tira hacia arriba
        }
        else {
            let velocity = velocity + gravityConst;   // normal: gravedad tira hacia abajo
        }
        
        // aplicar velocidad a posición
        let location = location + (32 * velocity);    // 32 palabras por fila
        let height = height + velocity;
        
        // gravedad normal: verificar colisión con suelo
        if (~gravityFlipped) {
            if (location > initialLocation) {
                let location = initialLocation;
                let height = initialHeight;
                let velocity = 0;
            }
        }
        // gravedad invertida: verificar colisión con techo
        else {
            // techo en altura 32 (deja espacio para UI arriba)
            if (height < 32) {
                let height = 32;
                let location = 16384 + (32 * 32);   // posición simple del techo
                let velocity = 0;
            }
        }
        
        // calcular qué tan lejos nos movimos
        let movementDelta = (location - oldLocation) / 32;
        
        // solo redibujar si la posición cambió
        if (~(movementDelta = 0)) {
            do eraseCube(oldLocation);
            do drawCube(cubeType);
        }
        
        return -1;
    }
    
    /**
     * jump:
     * hace que el cubo salte (o caiga si la gravedad está invertida)
     * retorna:
     *   5 = salto exitoso desde el suelo o techo
     *  -1 = ya está en el aire (sin salto)
     */
    method int jump() {
        // gravedad normal: saltar si está en el suelo
        if (~gravityFlipped) {
            if (location = initialLocation) {
                let velocity = jumpVelocity;   // velocidad negativa = hacia arriba
                return true;
            }
        }
        // gravedad invertida: saltar (caer) si está en el techo
        else {
            if (height = 32) {
                let velocity = -jumpVelocity;  // velocidad positiva = hacia abajo aquí
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * flipGravity:
     * alterna la dirección de la gravedad
     * solo puede invertir mientras está en medio del aire y cuando el cooldown es cero
     */
    method void flipGravity() {
        // solo puede invertir en medio del aire y si el cooldown lo permite
        if ((flipCooldown = 0) & (~(velocity = 0))) {  // FIXED: verificación explícita para velocity != 0
            // alternar gravedad
            let gravityFlipped = ~gravityFlipped;
            
            // revertir velocidad para transición suave
            let velocity = -velocity;
            
            // establecer cooldown para prevenir spam (aproximadamente 10 frames)
            let flipCooldown = 10;
        }
        return;
    }
    
    // -------- ayudantes de entrada --------
    
    /**
     * crouch:
     * reutilizado como disparador de inversión de gravedad (flecha abajo)
     */
    method void crouch() {
        do flipGravity();
        return;
    }
    
    /**
     * setVelocity:
     * establece directamente la velocidad vertical (usado por trampolín, etc.)
     */
    method void setVelocity(int vel) {
        let velocity = vel;
        return;
    }
    
    // -------- ayudantes de colisión --------
    
    /** retorna el borde superior actual del cubo (en filas de palabras) */
    method int collisionBoxTly() {
        return height;
    }
    
    /** retorna true si el cubo está en el suelo o en el techo - FIXED */
    method boolean isGrounded() {
        if (gravityFlipped) {
            return (height = 32);               // en el techo
        }
        return (location = initialLocation);    // en el suelo - FIXED: eliminado else, retorno directo
    }
    
    /** retorna true si la gravedad está invertida */
    method boolean isGravityFlipped() {
        return gravityFlipped;
    }
    
    // -------- ajuste estático de física --------
    
     /**
     * setPhysics:
     * ajusta la gravedad global y la fuerza de salto
     * gravedad recomendada: 2 a 4
     * salto recomendado: entre -20 y -30
     */
    
    function void setPhysics(int gravity, int jumpPower) {
        let gravityConst = gravity;
        let jumpVelocity = jumpPower;
        return;
    }
    
        /**
     * updateJump:
     * ajusta la fuerza del salto (logros, power-ups, etc.)
     * change: cuánto modificar el salto
     */
    function void updateJump(int change) {
        let jumpVelocity = jumpVelocity - (change * 5);
        
        // mantener velocidad de salto en límites razonables
        if ((jumpVelocity < (-45)) | (jumpVelocity > (-15))) {
            let jumpVelocity = -24;  // resetear a valor por defecto
        }
        return;
    }
    
    
        /**
     * swapFeet:
     * solo para compatibilidad con código viejo (sin efecto real)
     */
    method void swapFeet() {
        let feetPos = ~feetPos;
        return;
    }
}
