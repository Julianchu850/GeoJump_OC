class Spaceship {

    // Shared spawn position for all spaceships (in word units)
    static int rightmost;

    // Screen memory word index of the top-left of the sprite
    field int location;

    // Axis-aligned bounding box (AABB) in "word" (x) and "pixel" (y)
    field int tlx;   // top-left x (words)
    field int tly;   // top-left y (pixels)
    field int brx;   // bottom-right x (words)
    field int bry;   // bottom-right y (pixels)

    /** constructor
     *  Initializes a spaceship and sets the global rightmost spawn point.
     */
    constructor Spaceship new() {
        let location = 0;  // temporary placeholder so reset() knows "no sprite yet"
        do reset();
        let rightmost = 30;    // just off-screen to the right
        return this;
    }

    /** dispose
     *  Free this object when the game ends.
     */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    /** decrementRightmost
     *  Called once per frame from the main game loop to slowly pull
     *  the spawn position closer to the player as old ships move left.
     */
    function void decrementRightmost() {
        let rightmost = rightmost - 1;
        if (rightmost < 28) {
            let rightmost = 28;
        }
        return;
    }

    /** update
     *  Moves the spaceship one word to the left and redraws it.
     *  - If it has not reached the visible area yet (tlx > 28), just move.
     *  - Once on screen, erase old sprite, move, and redraw.
     *  - When it passes the left edge, call reset().
     */
    method void update() {
        var int oldLocation;

        // Not yet visible on screen → only move logically
        if (tlx > 28) {
            let location = location - 1;   // shift one word to the left
            let tlx = tlx - 1;
            let brx = brx - 1;
            return;
        }

        // Erase old sprite
        let oldLocation = location;
        do Graphics.eraseSpaceship(oldLocation);

        // Move left one word
        let location = location - 1;
        let tlx = tlx - 1;
        let brx = brx - 1;

        // Off the left side of the screen → spawn a new one
        if (brx < 0) {
            do reset();
            return;
        }

        // Draw at new location
        do Graphics.drawSpaceship(location);

        return;
    }

    /** reset
     *  Chooses a new random height (low / middle / high) and a random
     *  horizontal spacing from the previous spaceship, then places
     *  the sprite off-screen to the right.
     *
     *  Height types (same as original Pterodactyl):
     *   - 210: must crouch under
     *   - 215: optional movement
     *   - 235: must jump over
     */
    method void reset() {
        var int heightType;
        var int spriteHeight;

        // Erase previous spaceship if it existed
        if (location) {
            do Graphics.eraseSpaceship(location);
        }

        // Decide flight height
        let heightType = LCGRandom.randRange(0, 9);
        if (heightType < 7) {
            let tly = 210;   // require crouch
        }
        else {
            if (heightType = 9) {
                let tly = 235;   // require jump
            }
            else {
                let tly = 215;   // optional movement
            }
        }

        // Our spaceship sprite is 1 word (16px) wide and about 13px tall
        let spriteHeight = 13;

        // Random distance to the right of the previous spaceship
        let tlx = rightmost + LCGRandom.randRange(20, 1000);
        let rightmost = tlx;

        let brx = tlx + 1;                  // 1 word wide
        let bry = tly + spriteHeight;       // sprite height in pixels

        // Compute screen memory word index for the top-left of the sprite
        // Each pixel row is 32 words, so row = tly, column = tlx
        let location = (tly * 32) + tlx;

        return;
    }

    /** collision
     *  Axis-aligned rectangle intersection.
     *  Returns:
     *   0  → no collision
     *   1  → collision with lower half (crash)
     *  -1  → collision with upper half (springboard / bounce)
     *
     *  This matches the original Pterodactyl semantics used in GeometryGame.
     */
    method int collision(int tl1x, int tl1y, int br1x, int br1y) {
        // If separated on X axis, no collision
        if ((tlx > br1x) | (tl1x > brx)) {
            return 0;
        }

        // If separated on Y axis, no collision
        if ((tly > br1y) | (tl1y > bry)) {
            return 0;
        }

        // Decide whether we hit the "top" or "bottom" half of the ship.
        // We keep the same threshold as the original (tly + 8).
        if (br1y > (tly + 8)) {
            // Player bottom is below halfway down the ship → crash
            return 1;
        }

        // Player hit the top half → springboard / bounce
        return -1;
    }
}
